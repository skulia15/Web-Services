# Web-Services
Projects for the Web Services course at Reykjavik University

Includes projects implemented in .NET and Node.js

## Getting Started
.Net Core
npm or yarn package managers and a recent version of Node.js

### Installing
For each project in node you will need to run 'npm install' or 'yarn install'

## Authors

* **Skúli Arnarsson** 
* **Andri Karel Júlíusson** 
* **Smári Björn Gunnarsson** 

# Course Notes
## Client and Server
### Server side rendering
Pros
* The initial page of a website loads faster
* It’s great for static sites
* It’s rendering is great for SEO (search engine optimization)
* The client can be very light weight

Cons
* Frequent server requests
* Slow rendering
* Full page reloads
* Non-rich (non-dynamic) site interactions

### Client side rendering
Pros
* The server can just send DATA (e.g on JSON format)!
* Each client can render the data differently
* The programming language of the clients doesn´t matter
* Rich site interactions (dynamic interactions)
* Faster rendering
* Web apps!

Cons
* websites won’t be able to load until ALL the JavaScript is
downloaded to the browser
* Bad for SEO
* Initial load slow

## Web services
A web service is:
* Software that is available over the Internet or a private (intranet)
network
* uses a *standardized* messaging system
*  not tied to any one operating system or programming language

## API
Application Programming Interface

A web API is an API that is accessible over the internet

concept, not a technology+

## Different types of web services
SOAP
* xml

WCF (Windows communication foundation)

REST - Representational state transfer
* Usage of standard HTTP
* Different data formats
* performance and scalability
* Main Characteristics:
    * Client and Server are separated
    * Stateless -  State is sent with each request
    * Cacheable
    * Hypertext Driven

## Status Codes
Most common response status codes:

200: OK, request was sucessful

201: Created, Post request created an entity successfully

204: No content, When request doesn't return anything

301: Redirect / Moved permanently, The resource was moved

400: Bad request, Error on clients behalf. Request was incorrect.

401: Unauthorized, Client must specify authentication http header

402: Payment Required

403: Forbidden, The server knows clients idenity but the client isn't allowed to perform this action

404: Not found

412: Precondition failed, Can be used when a particular property is required, but wasn't provided by the client

500: Server error. Nothing a client can do

503: Service unavailable


## CRUD
Four basic functions of dealing with data
* Create
* Read
* Update
* Delete


## Restful services
**[FromBody]** attribute states that this parameter is to be found in the body of the incoming request

ModelState.IsValid checks whether the model from the request‘s body is
valid.

CreatedAtRoute method returns the route to the newly created resource

### Query parameters
Might look like this:  www.somedomain.com/api/records?genre=Rock

? denotes the start of a query string

Key - value pair
*  key is genre and value is Rock

The **[FromQuery]** attribute states that this parameter is to be found in the query string in the URL

## API Documentation
ASP.NET Web API, we can do this by using XML comments

XML comments should be added to:
* Controllers
* Controller methods
* Model classes passed in or returned from controller methods (both the classes
themselves and their properties)

XML documentation Example:
~~~~
/// <summary>
/// BlaBlaBla
/// </summary>
~~~~


## Models
 entity models:  C# classes that map
directly to a database table
* they look exactly like that corresponding database table
*  not a good idea to expose these models to the consumers of our web API 
* Good idea to have multiple models representing **the same** model

Entity models
* These are the models that map directly to our database tables and they should
only be use within the repository layers of our application

DTO models
* the models we would return to HTTP GET requests
* It is very common to have the models that the API return different from
the models that a user of the API would provide in the body of a POST request
* represents a *Lighter* version of a record

View models
* These are the models that the consumer would send in a request body when
sending a HTTP POST or PUT requests
*  it doesn’t make sense that the consumer can create every field of a model
*  Some fields should simply be generated by the database or the code of the Web API

## Interfaces 
Why use interfaces?
*  make our code more maintainable
*  make our code more extensible
*  make our response more easily and quickly to new features
*  make our code more testable

* Think of them as a contract
* When a class implements an Interface it makes a commitment to fulfill that
contract
* All interface members are public

## Depency injection
Depency injection eliminates the new keyword in a way

Means giving an object its instance variables.

Martin Fowler 

3 Types to inject:
* constructor injection
* property injection
* parameter injection

Makes code more maintainable

Interfaces can be used to create mocks of the implementation, thus
allowing developers to test classes in isolation

A common case for mocking is to mock some data as it is stored in a database.
This is done because having the testing project depending on the database is
not a good idea!

## Linq
Language integrated query

Query syntax and  Method syntax

A LINQ statement will usually result in a query object

The variable result will contain a query object until that query object is
materialized! Once that is done result will contain the result of the query! 

Ways that a query object can be materialized:
* Some code will try to enumerate the result, by calling foreach on the collection.
* The result is converted to a list or an array, using result.ToList() or result.ToArray()
* Trying to access a given value from the result, using First()/FirstOrDefault()/Single()/SingleOrDefault()
* Trying to use some of the values in the result, by calling aggregate functions such
as Count()/Min()/Max()/Average() etc.

Here are the four ways we can retrieve a single record,  they all have different usage details:
* First() returns the first record from a collection, and throws an exception if the
collection is empty
* FirstOrDefault() returns the first record from a collection or null if the collection is
empty.
* Single() returns the first record from a collection, and throws an exception if the
collection is empty OR if there are more than one record that match the query string.
* SingleOrDefault() returns the first record from a collection or null if the collection is
empty and throws an exception if there are more than one record that match the query
string.

#### The orderby Method
 these function are often used with the orderby method

Take(int x) 
*  returns x first records it finds, and throws an exception if the source is
null

Skip(int x)
* skips the first x records but returns the rest in the collection, and
throws an exception if the source is null

TakeWhile() 
* Keeps taking element until a specific condition is met, and throws an
exception if the source or predicate is null
 
SkipWhile()
* Skips all elements until a specific condition is met, and throws an
exception if the source or predicate is null

## Mapping
The separation between entity classes and DTO/ViewModel classes does
involve some code which must move data from one (or more) object(s) to
another, we call that mapping

* Some solutions have been developed which make this a bit easier, such as
Automapper!

* Automapper is smart and simply maps properties that
have the same name. If they don´t have the same name a
special mapping configuration is needed!

## Unit testing
Do note that each unit test should test a single unit. This unit is sometimes
referred to as "System Under Test" or SUT

 [TestInitialize] attribute. If
this method is present, it will get
called before each test in the class is
executed.

Each test method should have three sections
* Arrange - this section makes the necessary arrangements for the test
* Act - this section is usually just a single line, which executes the method being
tested
* Assert - this section asserts that all the post conditions are valid after the given
method being tested has executed

## Validating models
Can use: System.ComponentModel.DataAnnotations

Data annotations has a range of attributes to decorate properties of model
classes such as:
* MinLength / MaxLength
* Range
* RegularExpression
* Display / DisplayFormat
* DataType
* Required
* Compare

We can make the fields that
have a default value that isn´t
null nullable! We do that by
adding a question mark at the
end of the dataType.
* By doing this they will receive a default value of
null if they aren´t present in the model that is
sent in with the POST request

## Globalization and Localization
**Globalization** is the process of designing applications that support different cultures

**Localization** is the process of customizing an application for a given culture

**Internationalization** involves Globalization and Localization

accept-language

ASP.NET keeps track of two culture values
* Culture
* UICulture

The culture value determines the results of culture-dependent functions, such as the date, number, and currency formatting

The UICulture determines which resources are to be loaded for the page by the ResourceManager. The ResourceManager simply looks up culture-specific resources that is determined by CurrentUICulture. 

Every thread in .NET has CurrentCulture and CurrentUICulture objects. So ASP.NET inspects these values when rendering  culture-dependent functions

Every HTTP request has a header field called Accept-Language which determines which languages the user's browser supports

Accept-Language: en-us,en;q=0.5
* This means that the browser prefers English (United States english), but it can accept other types of English.
* The "q" parameter indicates an estimate of the user's
preference for that language. You can control the list of languages using your web browser.

Should the server side code provide the globalization or should the client code take care if it?
* A common approach is for the server side code to only return a single language and
then the client side code takes care of the globalization
*  example of this is a website that has multiple language options. Then the server would send some string constants in one language and the frontend code (usually javascript) will take care of “translating” it

Culture: It is a language and, optionally, a region.

Locale: A locale is the same as a culture

Neutral culture: A culture that has a specified language, but not a region (e.g. "en", "es")

Specific culture: A culture that has a specified language and region. (e.g. "enUS", "en-GB", "es-CL")

Access language headers with: 
* var languageheader = Request.Header["Accept-Language"];

## Paging
How to implement paging?
* We can use linq to create paging:

Instead of returning a list of
records it is common to
create an Envelope class

An Envelope class usually
contains a list of some data
and information about the
paging options 

Return an Envelope containing:
* Items: What we are going to display
* Total pages: Amount of pages we are able to display
* Page Size: how many records will be shown on each page
* Current Page: page we are displaying, we get this as a parameter

The HTTP requests access our API via the controllers so the controllers must also accept parameters for the pagenumber and pagesize
 
 We can get these parameters from a query that follows the route

* Example: /api/records?pageNumber=2&pageSize=15
    * The question mark denotes the start of the query
    * The ampersand denotes another query parameters

## Authentication

OAuth
* Login with facebook ,twitter etc.

Two types of clients:
* Silicon based clients: application(browser/app)
* Carbon based client: Carbon based is a the person working on the silicon based client

A good idea would be to have a single service (API)
that takes care of user authentication. 
* They are often called STS(security token service)

## Security
SQL injection

Cross-site scripting

CSRF (See-surf)
* The user has already visited a page A which has a CSRF vulnerability
* The user visit another page B which tries to exploit that vulnerability
* Page B contains code which tries to issue a request to page A, thereby performing actions on behalf of the current user, without that user knowing about it.

Security Misconfiguration
*  when an attacker can access unprotected files, default
accounts etc. to gain unauthorizes access to the system

## Caching

Caching helps to enhance speed by temporarily storing data - either on the client
or on the server - so that future requests to that same data can be served faster. 

Caching can be done on the client or on the server

The browser caches html, css, js and data but how can we  know that the data in the cache is still valid?

#### Etags
When a client makes a request to an api the api will mark its responses with an ETag
*  Etag is basically a hashed string
* It is a unique identifier for web caching validation.
* This key represents a resource (URL), if the resource changes then a new Etag is issued for that resource

"If-None-Match" Header
* if provided: the server will then compare the Etag with
the resource requested and if they match, the cached content will be returned together with a 304 HTTP response (Not modified).

if we wanted to issue a PUT/PATCH request we would have
to include the "If-Match" header!

When the API recieves the request it will check if the Etag is valid
* If the etag is valid then the server will not send any data with the response but only the status code 304. That basically means that the data the client has in it´s cache memory is still valid and can be used

IMemoryCache

Apps which run on multiple servers should ensure that sessions are sticky
when using the in-memory cache
* Sticky sessions ensure that subsequent requests from a client all go to the same
server
* Non-sticky sessions require a distributed cache to avoid cache consistency
problem

# Javascript - Node.js
JavaScript is described as a loosely- and dynamically typed scripting language
which can be used within different environments

When we declare a variable, write a literal
or construct an expression, the type is inferred. 

JavaScript is loosely typed. Thus, the type of a given variable can be changed after being defined.

## var
The problem with var:
* When declaring a variable with var you are stating that  the scope of that variable will be hoisted

let and const were introduced with ES6
* You should always consider using let or const instead of var

## const
pointers of const variables cannot be changed – you can
however change the object it is pointing to

## NodeJS 

is single threaded

to do synchronous,
concurrent programming we need to use things like callbacks, Promises or event handlers.

## let vs const vs var
var has no scoping, therefore declaring a variable with the same name will override the previous value.

let works the same way as var, except it has lexical scoping. Therefor this example won’t override the global version of foo.

Const in javascript is not like the const you are used to in C or C++. In javascript const follows the same scoping rules as let

All numbers in Javascript are represented as floats.

## ES6 Features

Arrow functions
* semantically different from regular functions when
dealing with the scope of *this*.

Classes

Object spread

Object destructuring

Template strings

Comparison
*  == does it’s best to find a way to similarity.
* === is strict equality which matches both type and value

## Express 
Middleware based routing framework

## Databases

Document based datastore

Does not require tables and schemas

Stores data as JSON (or similar)

Can be one big blob

Can use tables and schemas

Can be used exactly like SQL

Usually not ACID compliant (Atomicity, Consistency,
Isolation, Durability)

MongoDB driver
* Low level API
* No modeling

Mongoose
*  Higher level API
* Defines schemas to work with - SQL-like

# Quizes
Which of the following is generally considered to have defined the REST concept?
* Douglas Crockford 
* Misko Hevery 
* Roy Fielding 
* Leonard Richardsson 

<br>
<br>
<br>
<br>
<br>
Answer:  Roy Fielding

------------

A full-blown REST service has the following characteristics, except for one. Which one is NOT considered one of the main characteristics of a REST service?

* Hypertext driven 
* Cacheable 
* JSON data format 
* Client/Server architecture 
* Stateless 

<br>
<br>
<br>
<br>
<br>
Answer: JSON data format 

---------------

A web service with a single URL which only accepts a HTTP POST request, receives input on XML format and returns XML is probably a:
* Ruby on Rails project 
* SOAP service 
* Classic ASP project 
* REST service 

<br>
<br>
<br>
<br>
<br>
Answer: SOAP service 

---------------

A REST service for a Learning Management System has received a HTTP POST request, to create a new instance of a course. What is the most logical status code returned from the service, assuming the course instance can be properly created?
* 200 
* 204 
* 201 
* 404

<br>
<br>
<br>
<br>
<br>
Answer: 201

---------------

What is the preferred method when requesting data in a given format from a web service?
* To put it in the HTTP footer 
* Specify the content-type in the "Accept" HTTP header: Accept: application/json 
* To put it in the query string: http://server/api/courses?format=json 
* To put it in the URL: http://server/api/courses/json 
* To put it in the body of the HTTP request 

<br>
<br>
<br>
<br>
<br>
Answer: Specify the content-type in the "Accept" HTTP header: Accept: application/json 

-------------
 
Assume we want to support the given URL in our Web API:

/api/courses/123/assignments/234

where 123 is the integer ID of the course in question, and 234 is the integer ID of a given assignment in that course.

What is the MOST correct way - using Attribute routing - to decorate a method in a Web API Controller such that it supports this URL?

* Route["/api/courses/{courseID}/assignments/{assignmentID:string}]"

* RoutePrefix["/api/courses/123/assignments/234"]

* RoutePrefix["/api/courses/{courseID:int}/assignments/{assignmentID:int}] 

* Route["/api/courses/{courseID:int}/assignments/{assignmentID:int}]" 

* RoutePrefix["/api/courses/{courseID:int}/assignments/{assignmentID:string}] 

<br>
<br>
<br>
<br>
<br>
Answer: Route["/api/courses/{courseID:int}/assignments/{assignmentID:int}]"

-------------


What is the proper status code for a endpoint that handles HTTP DELETE requests?

* 418
* 400
* 204 
* 201 
<br>
<br>
<br>
<br>
<br>
Answer: 204

-------------

Which of the following is NOT among the methods used for versioning of Web APIs?
* Adding the version to the MIME type being reqested via the "Accept" header. 
* Adding a custom header to the request. Example: "api-version: 1" 
* Adding the version to a cookie. Example: "Version: v1" 
* Adding the version to the URL. Example: /api/v1/courses 
<br>
<br>
<br>
<br>
<br>
Answer: Adding the version to a cookie. Example: "Version: v1" 

-------------

If an ASP.NET Core Web API application wants to ensure that the response to a given request will contain status code 200, which of the following methods will do that?

* Declare the method as returning an object (or a list of objects), and then return such object(s).
* All other options are correct 
* Use IActionResult, and then return StatusCode(200, obj); 
* Use IActionResult, and then return new ObjectResult(obj); 
<br>
<br>
<br>
<br>
<br>
Answer: All other options are correct 

-------------

What would be the correct status code returned from an API method, if the client issues a request for /api/courses/9999, but there is no course with ID = 9999?

* 204
* 404 
* 500 
* 400 
* 303 
<br>
<br>
<br>
<br>
<br>
Answer: 404

-------------

Under what circumstances should an API method return HTTP status code 401?

* When the client HAS provided authentication data, but the given user doesn´t have permission to perform the given action
* When the client has issued a request for a method which doesn´t return any content, such as a DELETE method
* When the client has made some unspecified mistake in the request, i.e. could be a missing property value when creating a resource
* When the server is a teapot
* When the client has not provided any authentication data, but the method requires it 
<br>
<br>
<br>
<br>
<br>
Answer: When the client has not provided any authentication data, but the method requires it

-------------

A DTO class (Data Transfer Object) is a class which:

* is used to pass data from the web service to its clients 
* is used for validation of input from clients 
* contains the application business logic 
* maps to a database table 
* are used to pass data from clients to the web service 
<br>
<br>
<br>
<br>
<br>
Answer: is used to pass data from the web service to its clients

-------------

Entity objects are classes which:
* contain the application business logic
* map to database tables 
* are used to pass data from the web service to its clients 
* are used for validation of input from clients 
<br>
<br>
<br>
<br>
<br>
Answer: map to database tables 

-------------
Which of the following most correctly describes a service provider class?
* contains validation attributes on its properties 
* contains the application business logic 
* maps to a database table 
* handles all exceptions in the application and takes care of returning the correct status code
<br>
<br>
<br>
<br>
<br>
Answer: contains the application business logic

-------------
What support for different MIME types does ASP.NET Core Web API provide?
* It can return both JSON and XML, and allows adding support for other types (CSV, iCal, etc.) via custom formatters
* It can return both JSON and XML, but nothing else 
* It can return only JSON 
* It can return only XML 
* It has built in support for all known MIME types in the universe 
<br>
<br>
<br>
<br>
<br>
Answer: It can return both JSON and XML, and allows adding support for other types (CSV, iCal, etc.) via custom formatters

-------------

Which of the following LINQ methods will return a single item in a collection/table, null if no item is found, but will throw an exception if more than one is found?

* FirstOrDefault() 
* First() 
* SingleOrDefault() 
* Take(1) 
* Single() 
<br>
<br>
<br>
<br>
<br>
Answer: SingleOrDefault() 

-------------
Which of the following LINQ methods will NOT materialize a query?
* SingleOrDefault() 
* Count() 
* ToList() 
* Min() 
* OrderBy() 
<br>
<br>
<br>
<br>
<br>
Answer: OrderBy() 

-------------

_courses is a variable of type IRepository<Course>. What meaning does the "I"  in the beginning of the type IRepository have?
* It means that the type IRepository is a regular poco class 
* It has no meaning whatsoever
* It means that it will be mapped using IAutoMapper
* It indicates that the type IRepository is an interface 
<br>
<br>
<br>
<br>
<br>
Answer:  It indicates that the type IRepository is an interface 

-------------
AutoMapper is created to solve a particular problem. Which one?

* It allows us to inject dependencies into our application 
* It simplifies mapping between entity classes and database tables 
* It simplifies mapping between entity classes and DTO classes 
* It makes it easier to declare test instances of data in unit tests 
* It simplifies mapping between the business layer and the Web API layer 
<br>
<br>
<br>
<br>
<br>
Answer: It simplifies mapping between entity classes and DTO classes

-------------
What is the purpose of the attribute [TestInitialize] ?
* It means that a new instance of the class that is decorated with this attribute will be created before each unit test is run
* It means that the method that is decorated with this attribute is a unit test 
* There is no attribute called [TestInitialize]
* It means that the method that is decorated with this attribute will run before each unit test
<br>
<br>
<br>
<br>
<br>
Answer: It means that the method that is decorated with this attribute will run before each unit test

-------------
Which LINQ keyword can help us implementing a query which uses LEFT JOIN?
* into 
* where 
* select 
* equals 
* orderby 
<br>
<br>
<br>
<br>
<br>
Answer: into 

-------------
When implementing paging in ASP.NET Web API using the Entity Framework, two particular LINQ methods can help us to load a given page from a large list of items. Which two methods are those?
* Skip() / Take() 
* First() / Top() 
* Skip() / Top() 
* First() / Next() 
* First() / Take() 
<br>
<br>
<br>
<br>
<br>
Answer: Skip() / Take()

-------------
When a HTTP request is issued to a web service, which method should be used to indicate what (human) language the response is preferred to be in (if applicable)?
* The client has no way to indicate what language is preferred 
* Add a "lang" parameter to the query string: path/to/web/service?lang=is 
* Add a JSON object to the request body: { "lang" : "is" } 
* Add an "Accept-Language" HTTP header to the request 
* Put the language into the URL: /path/to/web/service/lang/is 
<br>
<br>
<br>
<br>
<br>
Answer: Add an "Accept-Language" HTTP header to the request 

-------------
The main purpose of a unit test is to:
* Test business logic 
* Test that the mapping between entity classes and database tables is correct 
* Test the integration between all parts of the system, i.e. Web API layer, business logic layer, and database layer
* Test routing in the Web API layer 
* Test DTO and ViewModel classes 
<br>
<br>
<br>
<br>
<br>
Answer:  Test business logic 

-------------

For a unit test method to be recognized as such by MSTest, it must meet certain qualifications. Which one? 
* The method must have three sections: Arrange, Act and Assert 
* The method must be marked with the [Fact] attribute, and there must be a constructor in the class which contains common setup code
* The method must be marked with the [TestMethod] attribute 
* The method must either be marked using the [Fact] attribute, or the [TestMethod] attribute
<br>
<br>
<br>
<br>
<br>
Answer: The method must be marked with the [TestMethod] attribute 

-------------

What should happen in the "Arrange" section in a unit test?
* It should call the method being tested 
* Nothing, it should all happen in the method marked as [TestInitialize] 
* It should throw an exception if the unit test expects one 
* It should set up the necessary test data 
* It should check that the result of calling a given method in the system under test meets the expectations
<br>
<br>
<br>
<br>
<br>
Answer: It should set up the necessary test data 

-------------

What should happen in the "Act" section in a unit test?
* It should call the method being tested 
* It should set up the necessary test data 
* It should check that the result of calling a given method in the system under test meets the expectations
* It should catch an exception if the system under test is expected to throw such an exception
<br>
<br>
<br>
<br>
<br>
Answer: It should call the method being tested 

-------------

What should happen in the "Assert" section in a unit test?

* It should set up the necessary test data 
* Nothing, it should all happen in the method marked as [TestInitialize] 
* It should call the method being tested 
* It should throw an exception if the unit test expects one 
* It should check that the result of calling a given method in the system under test meets the expectations
<br>
<br>
<br>
<br>
<br>
Answer:  It should check that the result of calling a given method in the system under test meets the expectations

-------------

Why would we want to make us of caching in our web services?
* because it is faster than a database and we won´t need a database if we have caching 
* We would want to use caching because it is a depency injection framework and depency injection is crusial when writing loosely coupled code
* To make our webservice faster 
* We wouldn´t want to use caching. It has no benefits at all 
<br>
<br>
<br>
<br>
<br>
Answer: To make our webservice faster 

-------------

To ensure that a method is properly tested, we need to:
* a) Test that the return value of the method is what is expected given its input 
* b) Test that any side effects (such as updating a record in a table) did in fact happen 
* c) Test that if the method has side effects (such as updating a record in a table), only the intended records were affected, and not others (i.e. only those records which were supposed to be updated should have changed, and not any others)
* a), b) and c) 
* Both a) and c) 
<br>
<br>
<br>
<br>
<br>
Answer: a), b) and c) 

-------------

Temp
<br>
<br>
<br>
<br>
<br>
Answer: 

-------------

Temp
<br>
<br>
<br>
<br>
<br>
Answer: 

-------------