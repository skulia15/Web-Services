# Web-Services
Projects for the Web Services course at Reykjavik University

Includes projects implemented in .NET and Node.js

## Getting Started
.Net Core
npm or yarn package managers and a recent version of Node.js

### Installing
For each project in node you will need to run 'npm install' or 'yarn install'

## Authors

* **Skúli Arnarsson** 
* **Andri Karel Júlíusson** 
* **Smári Björn Gunnarsson** 

# Course Notes
## Client and Server
### Server side rendering
Pros
* The initial page of a website loads faster
* It’s great for static sites
* It’s rendering is great for SEO (search engine optimization)
* The client can be very light weight

Cons
* Frequent server requests
* Slow rendering
* Full page reloads
* Non-rich (non-dynamic) site interactions

### Client side rendering
Pros
* The server can just send DATA (e.g on JSON format)!
* Each client can render the data differently
* The programming language of the clients doesn´t matter
* Rich site interactions (dynamic interactions)
* Faster rendering
* Web apps!

Cons
* websites won’t be able to load until ALL the JavaScript is
downloaded to the browser
* Bad for SEO
* Initial load slow

## Web services
A web service is:
* Software that is available over the Internet or a private (intranet)
network
* uses a *standardized* messaging system
*  not tied to any one operating system or programming language

## API
Application Programming Interface

A web API is an API that is accessible over the internet

concept, not a technology+

## Different types of web services
SOAP
* xml

WCF (Windows communication foundation)

REST - Representational state transfer
* Usage of standard HTTP
* Different data formats
* performance and scalability
* Main Characteristics:
    * Client and Server are separated
    * Stateless -  State is sent with each request
    * Cacheable
    * Hypertext Driven

## Status Codes
Most common response status codes:

200: OK, request was sucessful

201: Created, Post request created an entity successfully

204: No content, When request doesn't return anything

301: Redirect / Moved permanently, The resource was moved

400: Bad request, Error on clients behalf. Request was incorrect.

401: Unauthorized, Client must specify authentication http header

402: Payment Required

403: Forbidden, The server knows clients idenity but the client isn't allowed to perform this action

404: Not found

412: Precondition failed, Can be used when a particular property is required, but wasn't provided by the client

500: Server error. Nothing a client can do

503: Service unavailable


## CRUD
Four basic functions of dealing with data
* Create
* Read
* Update
* Delete


## Restful services
**[FromBody]** attribute states that this parameter is to be found in the body of the incoming request

ModelState.IsValid checks whether the model from the request‘s body is
valid.

CreatedAtRoute method returns the route to the newly created resource

### Query parameters
Might look like this:  www.somedomain.com/api/records?genre=Rock

? denotes the start of a query string

Key - value pair
*  key is genre and value is Rock

The **[FromQuery]** attribute states that this parameter is to be found in the query string in the URL

## API Documentation
ASP.NET Web API, we can do this by using XML comments

XML comments should be added to:
* Controllers
* Controller methods
* Model classes passed in or returned from controller methods (both the classes
themselves and their properties)

XML documentation Example:
~~~~
/// <summary>
/// BlaBlaBla
/// </summary>
~~~~


## Models
 entity models:  C# classes that map
directly to a database table
* they look exactly like that corresponding database table
*  not a good idea to expose these models to the consumers of our web API 
* Good idea to have multiple models representing **the same** model

Entity models
* These are the models that map directly to our database tables and they should
only be use within the repository layers of our application

DTO models
* the models we would return to HTTP GET requests
* It is very common to have the models that the API return different from
the models that a user of the API would provide in the body of a POST request
* represents a *Lighter* version of a record

View models
* These are the models that the consumer would send in a request body when
sending a HTTP POST or PUT requests
*  it doesn’t make sense that the consumer can create every field of a model
*  Some fields should simply be generated by the database or the code of the Web API

## Interfaces 
Why use interfaces?
*  make our code more maintainable
*  make our code more extensible
*  make our response more easily and quickly to new features
*  make our code more testable

* Think of them as a contract
* When a class implements an Interface it makes a commitment to fulfill that
contract
* All interface members are public

## Depency injection
Depency injection eliminates the new keyword in a way

Means giving an object its instance variables.

Martin Fowler 

3 Types to inject:
* constructor injection
* property injection
* parameter injection

Makes code more maintainable

Interfaces can be used to create mocks of the implementation, thus
allowing developers to test classes in isolation

A common case for mocking is to mock some data as it is stored in a database.
This is done because having the testing project depending on the database is
not a good idea!

## Linq
Language integrated query

Query syntax and  Method syntax

A LINQ statement will usually result in a query object

The variable result will contain a query object until that query object is
materialized! Once that is done result will contain the result of the query! 

Ways that a query object can be materialized:
* Some code will try to enumerate the result, by calling foreach on the collection.
* The result is converted to a list or an array, using result.ToList() or result.ToArray()
* Trying to access a given value from the result, using First()/FirstOrDefault()/Single()/SingleOrDefault()
* Trying to use some of the values in the result, by calling aggregate functions such
as Count()/Min()/Max()/Average() etc.

Here are the four ways we can retrieve a single record,  they all have different usage details:
* First() returns the first record from a collection, and throws an exception if the
collection is empty
* FirstOrDefault() returns the first record from a collection or null if the collection is
empty.
* Single() returns the first record from a collection, and throws an exception if the
collection is empty OR if there are more than one record that match the query string.
* SingleOrDefault() returns the first record from a collection or null if the collection is
empty and throws an exception if there are more than one record that match the query
string.

#### The orderby Method
 these function are often used with the orderby method

Take(int x) 
*  returns x first records it finds, and throws an exception if the source is
null

Skip(int x)
* skips the first x records but returns the rest in the collection, and
throws an exception if the source is null

TakeWhile() 
* Keeps taking element until a specific condition is met, and throws an
exception if the source or predicate is null
 
SkipWhile()
* Skips all elements until a specific condition is met, and throws an
exception if the source or predicate is null

## Mapping
The separation between entity classes and DTO/ViewModel classes does
involve some code which must move data from one (or more) object(s) to
another, we call that mapping

* Some solutions have been developed which make this a bit easier, such as
Automapper!

* Automapper is smart and simply maps properties that
have the same name. If they don´t have the same name a
special mapping configuration is needed!

## Unit testing
Do note that each unit test should test a single unit. This unit is sometimes
referred to as "System Under Test" or SUT

 [TestInitialize] attribute. If
this method is present, it will get
called before each test in the class is
executed.

Each test method should have three sections
* Arrange - this section makes the necessary arrangements for the test
* Act - this section is usually just a single line, which executes the method being
tested
* Assert - this section asserts that all the post conditions are valid after the given
method being tested has executed

## Validating models
Can use: System.ComponentModel.DataAnnotations

Data annotations has a range of attributes to decorate properties of model
classes such as:
* MinLength / MaxLength
* Range
* RegularExpression
* Display / DisplayFormat
* DataType
* Required
* Compare

We can make the fields that
have a default value that isn´t
null nullable! We do that by
adding a question mark at the
end of the dataType.
* By doing this they will receive a default value of
null if they aren´t present in the model that is
sent in with the POST request

## Exceptions