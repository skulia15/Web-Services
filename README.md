# Web-Services
Projects for the Web Services course at Reykjavik University

Includes projects implemented in .NET and Node.js

## Getting Started
.Net Core
npm or yarn package managers and a recent version of Node.js

### Installing
For each project in node you will need to run 'npm install' or 'yarn install'

## Authors

* **Skúli Arnarsson** 
* **Andri Karel Júlíusson** 
* **Smári Björn Gunnarsson** 

# Course Notes
## Client and Server
### Server side rendering
Pros
* The initial page of a website loads faster
* It’s great for static sites
* It’s rendering is great for SEO (search engine optimization)
* The client can be very light weight

Cons
* Frequent server requests
* Slow rendering
* Full page reloads
* Non-rich (non-dynamic) site interactions

### Client side rendering
Pros
* The server can just send DATA (e.g on JSON format)!
* Each client can render the data differently
* The programming language of the clients doesn´t matter
* Rich site interactions (dynamic interactions)
* Faster rendering
* Web apps!

Cons
* websites won’t be able to load until ALL the JavaScript is
downloaded to the browser
* Bad for SEO
* Initial load slow

## Web services
A web service is:
* Software that is available over the Internet or a private (intranet)
network
* uses a *standardized* messaging system
*  not tied to any one operating system or programming language

## API
Application Programming Interface

A web API is an API that is accessible over the internet

concept, not a technology+

## Different types of web services
SOAP
* xml

WCF (Windows communication foundation)

REST - Representational state transfer
* Usage of standard HTTP
* Different data formats
* performance and scalability
* Main Characteristics:
    * Client and Server are separated
    * Stateless -  State is sent with each request
    * Cacheable
    * Hypertext Driven

## Status Codes
Most common response status codes:

200: OK, request was sucessful

201: Created, Post request created an entity successfully

204: No content, When request doesn't return anything

301: Redirect / Moved permanently, The resource was moved

400: Bad request, Error on clients behalf. Request was incorrect.

401: Unauthorized, Client must specify authentication http header

402: Payment Required

403: Forbidden, The server knows clients idenity but the client isn't allowed to perform this action

404: Not found

412: Precondition failed, Can be used when a particular property is required, but wasn't provided by the client

500: Server error. Nothing a client can do

503: Service unavailable


## CRUD
Four basic functions of dealing with data
* Create
* Read
* Update
* Delete


## Restful services
**[FromBody]** attribute states that this parameter is to be found in the body of the incoming request

ModelState.IsValid checks whether the model from the request‘s body is
valid.

CreatedAtRoute method returns the route to the newly created resource

### Query parameters
Might look like this:  www.somedomain.com/api/records?genre=Rock

? denotes the start of a query string

Key - value pair
*  key is genre and value is Rock

The **[FromQuery]** attribute states that this parameter is to be found in the query string in the URL

## API Documentation
ASP.NET Web API, we can do this by using XML comments

XML comments should be added to:
* Controllers
* Controller methods
* Model classes passed in or returned from controller methods (both the classes
themselves and their properties)

XML documentation Example:
~~~~
/// <summary>
/// BlaBlaBla
/// </summary>
~~~~


## Models
 entity models:  C# classes that map
directly to a database table
* they look exactly like that corresponding database table
*  not a good idea to expose these models to the consumers of our web API 
* Good idea to have multiple models representing **the same** model

Entity models
* These are the models that map directly to our database tables and they should
only be use within the repository layers of our application

DTO models
* the models we would return to HTTP GET requests
* It is very common to have the models that the API return different from
the models that a user of the API would provide in the body of a POST request
* represents a *Lighter* version of a record

View models
* These are the models that the consumer would send in a request body when
sending a HTTP POST or PUT requests
*  it doesn’t make sense that the consumer can create every field of a model
*  Some fields should simply be generated by the database or the code of the Web API

## Interfaces 
Why use interfaces?
*  make our code more maintainable
*  make our code more extensible
*  make our response more easily and quickly to new features
*  make our code more testable

* Think of them as a contract
* When a class implements an Interface it makes a commitment to fulfill that
contract
* All interface members are public

## Depency injection
Depency injection eliminates the new keyword in a way

Means giving an object its instance variables.

Martin Fowler 

3 Types to inject:
* constructor injection
* property injection
* parameter injection

Makes code more maintainable

Interfaces can be used to create mocks of the implementation, thus
allowing developers to test classes in isolation

A common case for mocking is to mock some data as it is stored in a database.
This is done because having the testing project depending on the database is
not a good idea!

## Linq
Language integrated query

Query syntax and  Method syntax

A LINQ statement will usually result in a query object

The variable result will contain a query object until that query object is
materialized! Once that is done result will contain the result of the query! 

Ways that a query object can be materialized:
* Some code will try to enumerate the result, by calling foreach on the collection.
* The result is converted to a list or an array, using result.ToList() or result.ToArray()
* Trying to access a given value from the result, using First()/FirstOrDefault()/Single()/SingleOrDefault()
* Trying to use some of the values in the result, by calling aggregate functions such
as Count()/Min()/Max()/Average() etc.

Here are the four ways we can retrieve a single record,  they all have different usage details:
* First() returns the first record from a collection, and throws an exception if the
collection is empty
* FirstOrDefault() returns the first record from a collection or null if the collection is
empty.
* Single() returns the first record from a collection, and throws an exception if the
collection is empty OR if there are more than one record that match the query string.
* SingleOrDefault() returns the first record from a collection or null if the collection is
empty and throws an exception if there are more than one record that match the query
string.

#### The orderby Method
 these function are often used with the orderby method

Take(int x) 
*  returns x first records it finds, and throws an exception if the source is
null

Skip(int x)
* skips the first x records but returns the rest in the collection, and
throws an exception if the source is null

TakeWhile() 
* Keeps taking element until a specific condition is met, and throws an
exception if the source or predicate is null
 
SkipWhile()
* Skips all elements until a specific condition is met, and throws an
exception if the source or predicate is null

## Mapping
The separation between entity classes and DTO/ViewModel classes does
involve some code which must move data from one (or more) object(s) to
another, we call that mapping

* Some solutions have been developed which make this a bit easier, such as
Automapper!

* Automapper is smart and simply maps properties that
have the same name. If they don´t have the same name a
special mapping configuration is needed!

## Unit testing
Do note that each unit test should test a single unit. This unit is sometimes
referred to as "System Under Test" or SUT

 [TestInitialize] attribute. If
this method is present, it will get
called before each test in the class is
executed.

Each test method should have three sections
* Arrange - this section makes the necessary arrangements for the test
* Act - this section is usually just a single line, which executes the method being
tested
* Assert - this section asserts that all the post conditions are valid after the given
method being tested has executed

## Validating models
Can use: System.ComponentModel.DataAnnotations

Data annotations has a range of attributes to decorate properties of model
classes such as:
* MinLength / MaxLength
* Range
* RegularExpression
* Display / DisplayFormat
* DataType
* Required
* Compare

We can make the fields that
have a default value that isn´t
null nullable! We do that by
adding a question mark at the
end of the dataType.
* By doing this they will receive a default value of
null if they aren´t present in the model that is
sent in with the POST request

## Globalization and Localization
**Globalization** is the process of designing applications that support different cultures

**Localization** is the process of customizing an application for a given culture

**Internationalization** involves Globalization and Localization

accept-language

ASP.NET keeps track of two culture values
* Culture
* UICulture

The culture value determines the results of culture-dependent functions, such as the date, number, and currency formatting

The UICulture determines which resources are to be loaded for the page by the ResourceManager. The ResourceManager simply looks up culture-specific resources that is determined by CurrentUICulture. 

Every thread in .NET has CurrentCulture and CurrentUICulture objects. So ASP.NET inspects these values when rendering  culture-dependent functions

Every HTTP request has a header field called Accept-Language which determines which languages the user's browser supports

Accept-Language: en-us,en;q=0.5
* This means that the browser prefers English (United States english), but it can accept other types of English.
* The "q" parameter indicates an estimate of the user's
preference for that language. You can control the list of languages using your web browser.

Should the server side code provide the globalization or should the client code take care if it?
* A common approach is for the server side code to only return a single language and
then the client side code takes care of the globalization
*  example of this is a website that has multiple language options. Then the server would send some string constants in one language and the frontend code (usually javascript) will take care of “translating” it

Culture: It is a language and, optionally, a region.

Locale: A locale is the same as a culture

Neutral culture: A culture that has a specified language, but not a region (e.g. "en", "es")

Specific culture: A culture that has a specified language and region. (e.g. "enUS", "en-GB", "es-CL")

Access language headers with: 
* var languageheader = Request.Header["Accept-Language"];

## Paging
How to implement paging?
* We can use linq to create paging:

Instead of returning a list of
records it is common to
create an Envelope class

An Envelope class usually
contains a list of some data
and information about the
paging options 

Return an Envelope containing:
* Items: What we are going to display
* Total pages: Amount of pages we are able to display
* Page Size: how many records will be shown on each page
* Current Page: page we are displaying, we get this as a parameter

The HTTP requests access our API via the controllers so the controllers must also accept parameters for the pagenumber and pagesize
 
 We can get these parameters from a query that follows the route

* Example: /api/records?pageNumber=2&pageSize=15
    * The question mark denotes the start of the query
    * The ampersand denotes another query parameters

## Authentication

OAuth
* Login with facebook ,twitter etc.

Two types of clients:
* Silicon based clients: application(browser/app)
* Carbon based client: Carbon based is a the person working on the silicon based client

A good idea would be to have a single service (API)
that takes care of user authentication. 
* They are often called STS(security token service)

## Security
SQL injection

Cross-site scripting

CSRF (See-surf)
* The user has already visited a page A which has a CSRF vulnerability
* The user visit another page B which tries to exploit that vulnerability
* Page B contains code which tries to issue a request to page A, thereby performing actions on behalf of the current user, without that user knowing about it.

Security Misconfiguration
*  when an attacker can access unprotected files, default
accounts etc. to gain unauthorizes access to the system

## Caching

Caching helps to enhance speed by temporarily storing data - either on the client
or on the server - so that future requests to that same data can be served faster. 

Caching can be done on the client or on the server

The browser caches html, css, js and data but how can we  know that the data in the cache is still valid?

#### Etags
When a client makes a request to an api the api will mark its responses with an ETag
*  Etag is basically a hashed string
* It is a unique identifier for web caching validation.
* This key represents a resource (URL), if the resource changes then a new Etag is issued for that resource

"If-None-Match" Header
* if provided: the server will then compare the Etag with
the resource requested and if they match, the cached content will be returned together with a 304 HTTP response (Not modified).

if we wanted to issue a PUT/PATCH request we would have
to include the "If-Match" header!

When the API recieves the request it will check if the Etag is valid
* If the etag is valid then the server will not send any data with the response but only the status code 304. That basically means that the data the client has in it´s cache memory is still valid and can be used

IMemoryCache

Apps which run on multiple servers should ensure that sessions are sticky
when using the in-memory cache
* Sticky sessions ensure that subsequent requests from a client all go to the same
server
* Non-sticky sessions require a distributed cache to avoid cache consistency
problem

# Javascript - Node.js
JavaScript is described as a loosely- and dynamically typed scripting language
which can be used within different environments

When we declare a variable, write a literal
or construct an expression, the type is inferred. 

JavaScript is loosely typed. Thus, the type of a given variable can be changed after being defined.

## var
The problem with var:
* When declaring a variable with var you are stating that  the scope of that variable will be hoisted

let and const were introduced with ES6
* You should always consider using let or const instead of var

## const
pointers of const variables cannot be changed – you can
however change the object it is pointing to

## NodeJS 

is single threaded

to do synchronous,
concurrent programming we need to use things like callbacks, Promises or event handlers.

## let vs const vs var
var has no scoping, therefore declaring a variable with the same name will override the previous value.

let works the same way as var, except it has lexical scoping. Therefor this example won’t override the global version of foo.

Const in javascript is not like the const you are used to in C or C++. In javascript const follows the same scoping rules as let

All numbers in Javascript are represented as floats.

## ES6 Features

Arrow functions
* semantically different from regular functions when
dealing with the scope of *this*.

Classes

Object spread

Object destructuring

Template strings

Comparison
*  == does it’s best to find a way to similarity.
* === is strict equality which matches both type and value

## Express 
Middleware based routing framework

## Databases

Document based datastore

Does not require tables and schemas

Stores data as JSON (or similar)

Can be one big blob

Can use tables and schemas

Can be used exactly like SQL

Usually not ACID compliant (Atomicity, Consistency,
Isolation, Durability)

MongoDB driver
* Low level API
* No modeling

Mongoose
*  Higher level API
* Defines schemas to work with - SQL-like